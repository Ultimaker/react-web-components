"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const validate_1 = require("../../../utils/validate");
const content_1 = require("../../../utils/content");
const common_1 = require("../common");
const utils_1 = require("../../utils");
const comments_1 = require("../comments");
function callExpressionExtractor(calleeName, options) {
    validate_1.Validate.required.argument({ calleeName });
    let calleeNames = [].concat(calleeName);
    for (let name of calleeNames) {
        if (typeof name !== 'string' || name.length === 0) {
            throw new TypeError(`Argument 'calleeName' must be a non-empty string or an array containing non-empty strings`);
        }
    }
    common_1.validateOptions(options);
    content_1.validateContentOptions(options);
    let contentOptions = {
        trimWhiteSpace: false,
        preserveIndentation: true,
        replaceNewLines: false
    };
    if (options.content) {
        if (options.content.trimWhiteSpace !== undefined) {
            contentOptions.trimWhiteSpace = options.content.trimWhiteSpace;
        }
        if (options.content.preserveIndentation !== undefined) {
            contentOptions.preserveIndentation = options.content.preserveIndentation;
        }
        if (options.content.replaceNewLines !== undefined) {
            contentOptions.replaceNewLines = options.content.replaceNewLines;
        }
    }
    return (node, sourceFile, addMessage) => {
        if (node.kind === ts.SyntaxKind.CallExpression) {
            let callExpression = node;
            let matches = calleeNames.reduce((matchFound, name) => (matchFound || utils_1.JsUtils.calleeNameMatchesCallExpression(name, callExpression)), false);
            if (matches) {
                let message = extractArguments(callExpression, options.arguments, contentOptions);
                if (message) {
                    message.comments = comments_1.JsCommentUtils.extractComments(callExpression, sourceFile, options.comments);
                    addMessage(message);
                }
            }
        }
    };
}
exports.callExpressionExtractor = callExpressionExtractor;
function extractArguments(callExpression, argumentMapping, contentOptions) {
    let callArguments = callExpression.arguments;
    let textArgument = callArguments[argumentMapping.text], textPluralArgument = callArguments[argumentMapping.textPlural], contextArgument = callArguments[argumentMapping.context];
    let textPluralValid = typeof argumentMapping.textPlural !== 'number' || isTextLiteral(textPluralArgument);
    if (isTextLiteral(textArgument) && textPluralValid) {
        let message = {
            text: content_1.normalizeContent(textArgument.text, contentOptions)
        };
        if (isTextLiteral(textPluralArgument)) {
            message.textPlural = content_1.normalizeContent(textPluralArgument.text, contentOptions);
        }
        if (isTextLiteral(contextArgument)) {
            message.context = content_1.normalizeContent(contextArgument.text, contentOptions);
        }
        return message;
    }
    return null;
}
function isTextLiteral(expression) {
    return expression && (expression.kind === ts.SyntaxKind.StringLiteral || expression.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral);
}
